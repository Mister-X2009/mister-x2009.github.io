<!DOCTYPE html>
<html lang="de">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no, maximum-scale=1.0">
    <title>Voxel Survival Pro Mobile</title>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Inter:wght@400;700&family=VT323&display=swap');

        body {
            margin: 0;
            overflow: hidden;
            background-color: #000;
            font-family: 'Inter', sans-serif;
            user-select: none;
            touch-action: none;
        }

        canvas { display: block; }

        /* HUD */
        #hud {
            position: absolute;
            inset: 0;
            pointer-events: none;
            display: flex;
            flex-direction: column;
            justify-content: flex-end;
            align-items: center;
            padding-bottom: env(safe-area-inset-bottom, 10px);
        }

        #crosshair {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 16px;
            height: 16px;
        }
        #crosshair::before, #crosshair::after {
            content: ''; position: absolute; background: white; opacity: 0.8;
        }
        #crosshair::before { top: 7px; left: 0; width: 16px; height: 2px; }
        #crosshair::after { top: 0; left: 7px; width: 2px; height: 16px; }

        #mining-progress {
            position: absolute;
            top: 55%;
            left: 50%;
            transform: translateX(-50%);
            width: 60px;
            height: 8px;
            background: rgba(0,0,0,0.5);
            border: 1px solid white;
            display: none;
        }
        #mining-bar { width: 0%; height: 100%; background: #5f5; }

        /* Status Bars */
        #status-bars {
            display: flex;
            gap: 10px;
            margin-bottom: 10px;
        }
        .bar-container {
            width: 80px;
            height: 8px;
            background: rgba(0,0,0,0.5);
            border: 1.5px solid #fff;
            position: relative;
        }
        .bar-fill { height: 100%; transition: width 0.3s; }
        #health-fill { background: #ff4444; width: 100%; }
        #hunger-fill { background: #ffa500; width: 100%; }

        /* Hotbar */
        #hotbar {
            display: flex;
            gap: 3px;
            background: rgba(0,0,0,0.6);
            padding: 4px;
            border-radius: 4px;
            pointer-events: auto;
            max-width: 95vw;
            overflow-x: auto;
        }
        .slot {
            width: 40px;
            height: 40px;
            border: 2px solid #555;
            background: #333;
            display: flex;
            justify-content: center;
            align-items: center;
            position: relative;
            color: white;
            font-family: 'VT323', monospace;
            font-size: 16px;
            flex-shrink: 0;
        }
        .slot.active { border-color: #fff; background: #555; }
        .slot .icon { width: 28px; height: 28px; border-radius: 2px; }
        .count { position: absolute; bottom: 1px; right: 2px; pointer-events: none; text-shadow: 1px 1px 1px #000; }

        /* Mobile Controls */
        #joystick-container {
            position: absolute;
            bottom: 40px;
            left: 40px;
            width: 120px;
            height: 120px;
            background: rgba(255,255,255,0.1);
            border-radius: 50%;
            pointer-events: auto;
            display: flex;
            justify-content: center;
            align-items: center;
        }
        #joystick-knob {
            width: 50px;
            height: 50px;
            background: rgba(255,255,255,0.4);
            border-radius: 50%;
            position: absolute;
        }
        #action-buttons {
            position: absolute;
            bottom: 40px;
            right: 40px;
            display: flex;
            flex-direction: column;
            gap: 15px;
            pointer-events: auto;
        }
        .mobile-btn {
            width: 60px;
            height: 60px;
            background: rgba(255,255,255,0.2);
            border: 2px solid white;
            border-radius: 50%;
            color: white;
            display: flex;
            justify-content: center;
            align-items: center;
            font-weight: bold;
            font-size: 14px;
            backdrop-filter: blur(5px);
        }

        /* Inventory */
        #menu-overlay {
            position: absolute;
            inset: 0;
            background: rgba(0,0,0,0.85);
            display: none;
            justify-content: center;
            align-items: center;
            z-index: 2000;
            pointer-events: auto;
        }
        #inventory-container {
            background: #c6c6c6;
            border: 4px solid #fff;
            padding: 15px;
            display: flex;
            flex-direction: column;
            gap: 15px;
            color: #333;
            max-width: 90vw;
            max-height: 90vh;
            overflow-y: auto;
        }
        .grid { display: grid; gap: 4px; }
        .inv-grid { grid-template-columns: repeat(6, 1fr); }
        .craft-container { display: flex; gap: 10px; align-items: center; justify-content: center; }
        .craft-grid { grid-template-columns: repeat(2, 1fr); }
    </style>
</head>
<body>

    <div id="hud">
        <div id="mining-progress"><div id="mining-bar"></div></div>
        <div id="status-bars">
            <div class="bar-container"><div id="health-fill" class="bar-fill"></div></div>
            <div class="bar-container"><div id="hunger-fill" class="bar-fill"></div></div>
        </div>
        <div id="hotbar"></div>
    </div>

    <!-- Mobile Controls -->
    <div id="joystick-container">
        <div id="joystick-knob"></div>
    </div>

    <div id="action-buttons">
        <div class="mobile-btn" id="btn-jump">SPRUNG</div>
        <div class="mobile-btn" id="btn-inv">INV</div>
    </div>

    <div id="menu-overlay">
        <div id="inventory-container">
            <div style="display:flex; justify-content: space-between; align-items: center">
                <h3 style="margin:0">Inventar</h3>
                <button onclick="toggleMenu()" style="padding: 5px 15px">X</button>
            </div>
            <div class="craft-container">
                <div id="crafting-grid" class="grid craft-grid"></div>
                <div style="font-size: 20px;">➜</div>
                <div id="craft-result" class="slot" onclick="takeCraftResult()"></div>
            </div>
            <div id="main-inventory" class="grid inv-grid"></div>
            <p style="font-size: 10px; margin: 0;">Kurz Tippen (Spiel): Block setzen. Lang Tippen: Block abbauen.</p>
        </div>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/simplex-noise/2.4.0/simplex-noise.min.js"></script>

    <script>
        // --- CONFIG ---
        const BLOCK_TYPES = {
            air: { id: 0 },
            grass: { id: 1, name: "Gras", stackable: true, hardness: 0.6, color: '#5d8c36' },
            dirt: { id: 2, name: "Erde", stackable: true, hardness: 0.5, color: '#553a26' },
            stone: { id: 3, name: "Stein", stackable: true, hardness: 1.5, tool: 'pickaxe', color: '#888' },
            log: { id: 4, name: "Holzstamm", stackable: true, hardness: 1.0, tool: 'axe', color: '#4b3621' },
            leaves: { id: 5, name: "Blätter", stackable: true, hardness: 0.2, color: '#2d5a27' },
            planks: { id: 6, name: "Bretter", stackable: true, hardness: 1.0, tool: 'axe', color: '#8a6a4a' },
            glass: { id: 7, name: "Glas", stackable: true, hardness: 0.3, transparent: true, color: '#add8e6' },
            coal_ore: { id: 8, name: "Kohle-Erz", stackable: true, hardness: 2.0, tool: 'pickaxe', color: '#333' },
            stick: { id: 10, name: "Stock", stackable: true, isItem: true, color: '#7a5a3a' },
            wooden_pickaxe: { id: 11, name: "Holz-Picke", stackable: false, isItem: true, power: 2, toolType: 'pickaxe', color: '#8a6a4a' }
        };

        const RECIPES = [
            { input: [4, 0, 0, 0], output: { id: 6, count: 4 } },   
            { input: [6, 0, 6, 0], output: { id: 10, count: 4 } },  
            { input: [6, 6, 10, 0], output: { id: 11, count: 1 } } 
        ];

        // --- VARS ---
        let scene, camera, renderer, raycaster, clock;
        let player, velocity, yaw = 0, pitch = 0;
        let blocks = [];
        let inventory = new Array(36).fill(null);
        let craftingSlots = [0, 0, 0, 0];
        let craftResult = null;
        let hotbarIndex = 0;
        let isMenuOpen = false;
        let health = 20, hunger = 20;
        let interactionTime = 0, isMining = false;
        let canJump = false;

        const input = { forward: 0, right: 0, jump: false };
        
        // Mobile Touch Vars
        let joystickCenter = { x: 0, y: 0 };
        let touchStartPos = { x: 0, y: 0 };
        let isTouching = false;
        let longPressTimer = null;

        function init() {
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x87CEEB);
            scene.fog = new THREE.Fog(0x87CEEB, 20, 50);

            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            
            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(window.devicePixelRatio);
            document.body.appendChild(renderer.domElement);

            scene.add(new THREE.AmbientLight(0xffffff, 0.7));
            const sun = new THREE.DirectionalLight(0xffffff, 0.8);
            sun.position.set(10, 30, 10);
            scene.add(sun);

            clock = new THREE.Clock();
            raycaster = new THREE.Raycaster();
            velocity = new THREE.Vector3();

            setupTextures();
            generateWorld();
            
            player = new THREE.Group();
            player.position.set(0, 20, 0);
            scene.add(player);
            player.add(camera);

            setupMobileControls();
            setupInventory();
            animate();
        }

        const textures = {};
        function setupTextures() {
            const createTex = (c) => {
                const canvas = document.createElement('canvas');
                canvas.width = 16; canvas.height = 16;
                const ctx = canvas.getContext('2d');
                for(let i=0; i<256; i++) {
                    ctx.fillStyle = Math.random() > 0.5 ? c : c; // simplified
                    ctx.fillRect(i%16, Math.floor(i/16), 1, 1);
                }
                const t = new THREE.CanvasTexture(canvas);
                t.magFilter = THREE.NearestFilter;
                return t;
            };
            textures.grass_top = createTex('#5d8c36');
            textures.dirt = createTex('#553a26');
            textures.stone = createTex('#888');
        }

        function getMat(id) {
            if(id === 1) return [null,null,new THREE.MeshLambertMaterial({map: textures.grass_top}),new THREE.MeshLambertMaterial({map: textures.dirt}),null,null].map(m => m || new THREE.MeshLambertMaterial({map: textures.dirt}));
            if(id === 2) return new THREE.MeshLambertMaterial({map: textures.dirt});
            if(id === 3) return new THREE.MeshLambertMaterial({map: textures.stone});
            const type = Object.values(BLOCK_TYPES).find(t => t.id === id);
            return new THREE.MeshLambertMaterial({color: type?.color || '#fff'});
        }

        function generateWorld() {
            const simplex = new SimplexNoise();
            for(let x = -10; x < 10; x++) {
                for(let z = -10; z < 10; z++) {
                    const h = Math.floor(simplex.noise2D(x/10, z/10) * 3) + 5;
                    for(let y = 0; y < h; y++) {
                        createBlock(x, y, z, y === h-1 ? 1 : (y < h-3 ? 3 : 2));
                    }
                }
            }
        }

        function createBlock(x, y, z, id) {
            const mesh = new THREE.Mesh(new THREE.BoxGeometry(1, 1, 1), getMat(id));
            mesh.position.set(x, y, z);
            mesh.userData.typeId = id;
            scene.add(mesh);
            blocks.push(mesh);
        }

        // --- MOBILE STEERING ---
        function setupMobileControls() {
            const joy = document.getElementById('joystick-container');
            const knob = document.getElementById('joystick-knob');

            joy.addEventListener('touchstart', (e) => {
                const rect = joy.getBoundingClientRect();
                joystickCenter = { x: rect.left + rect.width/2, y: rect.top + rect.height/2 };
            });

            joy.addEventListener('touchmove', (e) => {
                e.preventDefault();
                const touch = e.touches[0];
                let dx = touch.clientX - joystickCenter.x;
                let dy = touch.clientY - joystickCenter.y;
                const dist = Math.min(Math.sqrt(dx*dx + dy*dy), 50);
                const angle = Math.atan2(dy, dx);
                
                const moveX = Math.cos(angle) * dist;
                const moveY = Math.sin(angle) * dist;
                
                knob.style.transform = `translate(${moveX}px, ${moveY}px)`;
                
                input.right = dx / 50;
                input.forward = -dy / 50;
            });

            joy.addEventListener('touchend', () => {
                knob.style.transform = `translate(0px, 0px)`;
                input.forward = 0; input.right = 0;
            });

            // Umsehen & Aktionen (rechter Bereich)
            window.addEventListener('touchstart', (e) => {
                const touch = e.touches[0];
                if(touch.clientX > window.innerWidth / 2) {
                    touchStartPos = { x: touch.clientX, y: touch.clientY };
                    
                    // Langes Drücken zum Abbauen
                    longPressTimer = setTimeout(() => {
                        isMining = true;
                        interactionTime = Date.now();
                    }, 400);
                }
            }, { passive: false });

            window.addEventListener('touchmove', (e) => {
                const touch = e.touches[0];
                if(touch.clientX > window.innerWidth / 2) {
                    const dx = touch.clientX - touchStartPos.x;
                    const dy = touch.clientY - touchStartPos.y;
                    
                    if(Math.abs(dx) > 5 || Math.abs(dy) > 5) clearTimeout(longPressTimer);
                    
                    yaw -= dx * 0.005;
                    pitch = Math.max(-Math.PI/2, Math.min(Math.PI/2, pitch - dy * 0.005));
                    player.rotation.y = yaw;
                    camera.rotation.x = pitch;
                    
                    touchStartPos = { x: touch.clientX, y: touch.clientY };
                }
            });

            window.addEventListener('touchend', (e) => {
                const touch = e.changedTouches[0];
                clearTimeout(longPressTimer);
                
                if(isMining) {
                    isMining = false;
                    document.getElementById('mining-progress').style.display = 'none';
                } else if(touch.clientX > window.innerWidth / 2 && !isMenuOpen) {
                    // Kurzes Tippen -> Block setzen
                    performAction(false);
                }
            });

            document.getElementById('btn-jump').addEventListener('touchstart', () => input.jump = true);
            document.getElementById('btn-jump').addEventListener('touchend', () => input.jump = false);
            document.getElementById('btn-inv').addEventListener('touchstart', toggleMenu);
        }

        // --- INVENTORY ---
        function setupInventory() {
            addItem(4, 10); // Startholz
            updateUI();
        }

        function addItem(id, count = 1) {
            const type = Object.values(BLOCK_TYPES).find(t => t.id === id);
            let slot = inventory.find(s => s && s.id === id && s.count < 64);
            if(type.stackable && slot) { slot.count += count; }
            else {
                let empty = inventory.findIndex(s => s === null);
                if(empty !== -1) inventory[empty] = { id, count };
            }
            updateUI();
        }

        function toggleMenu() {
            isMenuOpen = !isMenuOpen;
            document.getElementById('menu-overlay').style.display = isMenuOpen ? 'flex' : 'none';
            updateUI();
        }

        function updateUI() {
            const hb = document.getElementById('hotbar');
            hb.innerHTML = '';
            for(let i=0; i<9; i++) {
                const item = inventory[i];
                const active = i === hotbarIndex;
                hb.innerHTML += `<div class="slot ${active?'active':''}" onclick="setHotbar(${i})">${item ? renderIcon(item.id) : ''}${item && item.count > 1 ? `<span class="count">${item.count}</span>` : ''}</div>`;
            }

            if(isMenuOpen) {
                const inv = document.getElementById('main-inventory');
                inv.innerHTML = inventory.map((item, i) => `<div class="slot" onclick="clickInv(${i})">${item ? renderIcon(item.id) : ''}${item && item.count > 1 ? `<span class="count">${item.count}</span>` : ''}</div>`).join('');
                
                const cGrid = document.getElementById('crafting-grid');
                cGrid.innerHTML = craftingSlots.map((id, i) => `<div class="slot" onclick="clearCraft(${i})">${id > 0 ? renderIcon(id) : ''}</div>`).join('');
                
                const res = document.getElementById('craft-result');
                res.innerHTML = craftResult ? renderIcon(craftResult.id) + (craftResult.count > 1 ? `<span class="count">${craftResult.count}</span>` : '') : '';
            }
        }

        window.setHotbar = (i) => { hotbarIndex = i; updateUI(); };
        window.clickInv = (i) => {
            const item = inventory[i];
            if(!item) return;
            let cIdx = craftingSlots.findIndex(s => s === 0);
            if(cIdx !== -1) {
                craftingSlots[cIdx] = item.id;
                item.count--; if(item.count <= 0) inventory[i] = null;
                checkRecipes(); updateUI();
            }
        };
        window.clearCraft = (i) => { craftingSlots[i] = 0; checkRecipes(); updateUI(); };

        function checkRecipes() {
            craftResult = null;
            const match = RECIPES.find(r => JSON.stringify(r.input) === JSON.stringify(craftingSlots));
            if(match) craftResult = {...match.output};
        }

        window.takeCraftResult = () => {
            if(craftResult && addItem(craftResult.id, craftResult.count)) {
                craftingSlots = [0,0,0,0]; craftResult = null; updateUI();
            }
        };

        function renderIcon(id) {
            const type = Object.values(BLOCK_TYPES).find(t => t.id === id);
            return `<div class="icon" style="background: ${type?.color || '#fff'}"></div>`;
        }

        // --- GAME LOOP ---
        function performAction(isDestroy) {
            raycaster.setFromCamera({x:0, y:0}, camera);
            const hits = raycaster.intersectObjects(blocks);
            if(hits.length > 0 && hits[0].distance < 5) {
                const h = hits[0];
                if(isDestroy) {
                    addItem(h.object.userData.typeId, 1);
                    scene.remove(h.object);
                    blocks = blocks.filter(b => b !== h.object);
                } else {
                    const item = inventory[hotbarIndex];
                    if(!item || BLOCK_TYPES[Object.keys(BLOCK_TYPES).find(k => BLOCK_TYPES[k].id === item.id)].isItem) return;
                    const pos = h.object.position.clone().add(h.face.normal);
                    if(pos.distanceTo(player.position) > 1.2) {
                        createBlock(pos.x, pos.y, pos.z, item.id);
                        item.count--; if(item.count <= 0) inventory[hotbarIndex] = null;
                        updateUI();
                    }
                }
            }
        }

        function animate() {
            requestAnimationFrame(animate);
            const d = clock.getDelta();
            
            if(!isMenuOpen) {
                // Physics
                velocity.y -= 0.01;
                player.translateZ(input.forward * 0.1);
                player.translateX(input.right * 0.1);
                
                player.position.y += velocity.y;
                raycaster.set(player.position, new THREE.Vector3(0,-1,0));
                const g = raycaster.intersectObjects(blocks);
                if(g.length > 0 && g[0].distance < 1.6) {
                    player.position.y += 1.6 - g[0].distance;
                    velocity.y = 0; canJump = true;
                }
                if(input.jump && canJump) { velocity.y = 0.15; canJump = false; }

                // Survival
                hunger = Math.max(0, hunger - 0.005 * d);
                document.getElementById('health-fill').style.width = (health/20 * 100) + '%';
                document.getElementById('hunger-fill').style.width = (hunger/20 * 100) + '%';

                // Mining
                if(isMining) {
                    raycaster.setFromCamera({x:0,y:0}, camera);
                    const hs = raycaster.intersectObjects(blocks);
                    if(hs.length > 0 && hs[0].distance < 5) {
                        const elapsed = Date.now() - interactionTime;
                        const prog = document.getElementById('mining-progress'); prog.style.display = 'block';
                        const type = Object.values(BLOCK_TYPES).find(t => t.id === hs[0].object.userData.typeId);
                        const p = Math.min(elapsed / (type.hardness * 1000), 1);
                        document.getElementById('mining-bar').style.width = (p*100)+'%';
                        if(p >= 1) { performAction(true); isMining = false; prog.style.display='none'; }
                    }
                }
            }
            renderer.render(scene, camera);
        }

        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });

        init();
    </script>
</body>
</html>

