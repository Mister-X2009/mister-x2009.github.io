<!DOCTYPE html>
<html lang="de">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no, maximum-scale=1.0">
    <title>Iso-Minecraft JS</title>
    <style>
        /* --- CSS STYLING --- */
        @import url('https://fonts.googleapis.com/css2?family=Press+Start+2P&display=swap');

        body {
            margin: 0;
            overflow: hidden;
            background-color: #1a1a1a;
            font-family: 'Press Start 2P', cursive; /* Pixel Font */
            user-select: none;
            -webkit-user-select: none;
            /* Verhindert Kontextmenü bei langem Drücken */
            -webkit-touch-callout: none;
        }

        /* Der Canvas, auf dem das Spiel gerendert wird */
        canvas {
            display: block;
            width: 100vw;
            height: 100vh;
            /* Pixelated Look erzwingen */
            image-rendering: pixelated;
            image-rendering: -moz-crisp-edges;
            image-rendering: crisp-edges;
            touch-action: none; /* Wichtig für eigene Touch-Events */
        }

        /* --- UI LAYOUT --- */
        #ui-layer {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none; /* Klicks gehen durch UI durch (außer Buttons) */
            display: none; /* Standardmäßig aus, an wenn Spiel läuft */
        }

        /* Mobile Controls */
        .mobile-controls {
            display: none; /* Wird per JS aktiviert wenn Touch erkannt wird */
            pointer-events: auto;
        }

        #dpad-area {
            position: absolute;
            bottom: 20px;
            left: 20px;
            width: 150px;
            height: 150px;
            background: rgba(0,0,0,0.2);
            border-radius: 50%;
            touch-action: none;
        }

        #dpad-stick {
            position: absolute;
            top: 50%;
            left: 50%;
            width: 50px;
            height: 50px;
            background: rgba(255, 255, 255, 0.5);
            border-radius: 50%;
            transform: translate(-50%, -50%);
            pointer-events: none;
        }

        .action-btn {
            position: absolute;
            width: 70px;
            height: 70px;
            background: rgba(255, 255, 255, 0.3);
            border: 2px solid white;
            border-radius: 10px;
            color: white;
            display: flex;
            justify-content: center;
            align-items: center;
            font-size: 10px;
            touch-action: manipulation;
            pointer-events: auto;
        }

        .action-btn:active { background: rgba(255, 255, 255, 0.6); }

        #btn-jump { bottom: 40px; right: 20px; }
        /* Action Button entfernt, da Interaktion jetzt über Tap/Hold läuft */
        /* #btn-action { bottom: 120px; right: 20px; background: rgba(200, 50, 50, 0.4); } */

        /* --- HAUPTMENÜ --- */
        #main-menu {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.85);
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 100;
            color: white;
            text-align: center;
        }

        h1 {
            color: #5f5;
            text-shadow: 4px 4px 0px #000;
            font-size: 40px;
            margin-bottom: 20px;
            line-height: 1.5;
        }

        .menu-btn {
            background-color: #777;
            border: 4px solid #fff;
            border-bottom: 6px solid #444;
            border-right: 6px solid #444;
            color: white;
            padding: 15px 30px;
            font-family: 'Press Start 2P', cursive;
            font-size: 16px;
            margin: 10px;
            cursor: pointer;
            transition: transform 0.1s;
            text-transform: uppercase;
        }

        .menu-btn:active {
            transform: translate(2px, 2px);
            border-bottom: 4px solid #444;
            border-right: 4px solid #444;
        }

        #debug-info {
            position: absolute;
            top: 10px;
            left: 10px;
            color: #eee;
            font-size: 10px;
            text-shadow: 1px 1px 0 #000;
            pointer-events: none;
        }

        /* Slot Auswahl (Hotbar-Simulation) */
        #hotbar {
            position: absolute;
            bottom: 10px;
            left: 50%;
            transform: translateX(-50%);
            display: flex;
            gap: 5px;
            pointer-events: auto;
        }
        
        .slot {
            width: 40px;
            height: 40px;
            border: 3px solid #555;
            background: rgba(0,0,0,0.5);
            cursor: pointer;
        }
        
        .slot.active { border-color: #eee; transform: scale(1.1); }
        .slot-color { width: 100%; height: 100%; }

    </style>
</head>
<body>

    <!-- SPIEL UI -->
    <div id="ui-layer">
        <div id="debug-info">FPS: 60</div>
        
        <div id="hotbar">
            <!-- Wird per JS gefüllt -->
        </div>

        <!-- Mobile Controls -->
        <div class="mobile-controls">
            <div id="dpad-area">
                <div id="dpad-stick"></div>
            </div>
            <div id="btn-jump" class="action-btn">JUMP</div>
        </div>
    </div>

    <!-- HAUPTMENÜ -->
    <div id="main-menu">
        <h1>ISO CRAFT<br><span style="font-size:14px; color:#aaa">Web Edition v2</span></h1>
        <button class="menu-btn" id="start-btn">Welt betreten</button>
        <div style="margin-top:20px; font-size: 10px; color: #888;">
            <p>PC: WASD + Space | Maus: Tippen (Bauen) / Halten (Abbauen)</p>
            <p>Mobile: Joystick | Tippen (Bauen) / Halten (Abbauen)</p>
        </div>
    </div>

    <!-- THREE.JS -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <!-- Simplex Noise für Terrain -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/simplex-noise/2.4.0/simplex-noise.min.js"></script>

    <script>
        /**
         * ISO-MINECRAFT LOGIK v2
         */

        // --- KONFIGURATION ---
        const RENDER_SCALE = 4;
        const CHUNK_SIZE = 16;
        const WORLD_SIZE = 4;
        const BLOCK_SIZE = 10;
        const VIEW_SIZE = 180; // Größerer Wert = Mehr Welt sichtbar (Zoom out)
        
        // Globale Variablen
        let scene, camera, renderer, raycaster, mouse;
        let player, selectionBox;
        let blocks = [];
        let isGameActive = false;
        let isMobile = false;
        
        // Physics
        const velocity = new THREE.Vector3();
        const direction = new THREE.Vector3();
        let canJump = false;
        let prevTime = performance.now();

        // Input State
        const input = {
            forward: false,
            backward: false,
            left: false,
            right: false,
            jump: false,
            sprint: false
        };

        // Interaction State
        let interactionTimer = null;
        let pointerDownTime = 0;
        let isLongPressAction = false;
        let lastIntersect = null; // Speichert das Ziel des Raycasts

        // Material Palette
        const materials = {};
        let currentBlockType = 'dirt';

        // --- TEXTUR GENERATOR ---
        function createTexture(type) {
            const canvas = document.createElement('canvas');
            canvas.width = 64;
            canvas.height = 64;
            const ctx = canvas.getContext('2d');

            if (type === 'grass_top') {
                ctx.fillStyle = '#4C9236'; ctx.fillRect(0,0,64,64);
                for(let i=0; i<400; i++) {
                    ctx.fillStyle = Math.random() > 0.5 ? '#3B7A26' : '#5DA844';
                    ctx.fillRect(Math.random()*64, Math.random()*64, 4, 4);
                }
            } else if (type === 'dirt') {
                ctx.fillStyle = '#6d4c38'; ctx.fillRect(0,0,64,64);
                for(let i=0; i<300; i++) {
                    ctx.fillStyle = Math.random() > 0.5 ? '#573B2B' : '#7D5A46';
                    ctx.fillRect(Math.random()*64, Math.random()*64, 4, 4);
                }
            } else if (type === 'grass_side') {
                ctx.fillStyle = '#6d4c38'; ctx.fillRect(0,0,64,64);
                ctx.fillStyle = '#4C9236'; ctx.fillRect(0,0,64,18);
                for(let i=0; i<50; i++) {
                    ctx.fillRect(Math.random()*64, 15, 4, Math.random()*10);
                }
            } else if (type === 'stone') {
                ctx.fillStyle = '#7d7d7d'; ctx.fillRect(0,0,64,64);
                for(let i=0; i<200; i++) {
                    ctx.fillStyle = Math.random() > 0.5 ? '#666' : '#999';
                    ctx.fillRect(Math.random()*64, Math.random()*64, 5, 5);
                }
            } else if (type === 'wood') {
                ctx.fillStyle = '#634730'; ctx.fillRect(0,0,64,64);
                ctx.fillStyle = '#4a332a';
                for(let i=0; i<6; i++) {
                    ctx.fillRect(i*10 + 2, 0, 4, 64);
                }
            } else if (type === 'selection') {
                // Nicht genutzt für Textur, aber Platzhalter
            }

            const texture = new THREE.CanvasTexture(canvas);
            texture.magFilter = THREE.NearestFilter;
            texture.minFilter = THREE.NearestFilter;
            return texture;
        }

        function initMaterials() {
            const grassTop = createTexture('grass_top');
            const grassSide = createTexture('grass_side');
            const dirt = createTexture('dirt');
            const stone = createTexture('stone');
            const wood = createTexture('wood');

            materials.grass = [
                new THREE.MeshLambertMaterial({ map: grassSide }),
                new THREE.MeshLambertMaterial({ map: grassSide }),
                new THREE.MeshLambertMaterial({ map: grassTop }),
                new THREE.MeshLambertMaterial({ map: dirt }),
                new THREE.MeshLambertMaterial({ map: grassSide }),
                new THREE.MeshLambertMaterial({ map: grassSide })
            ];
            materials.dirt = new THREE.MeshLambertMaterial({ map: dirt });
            materials.stone = new THREE.MeshLambertMaterial({ map: stone });
            materials.wood = new THREE.MeshLambertMaterial({ map: wood });

            // UI
            const hotbar = document.getElementById('hotbar');
            hotbar.innerHTML = '';
            ['grass', 'dirt', 'stone', 'wood'].forEach(type => {
                const el = document.createElement('div');
                el.className = 'slot';
                el.onclick = (e) => {
                    e.stopPropagation(); // Verhindert Bauen beim Klicken auf UI
                    document.querySelectorAll('.slot').forEach(s => s.classList.remove('active'));
                    el.classList.add('active');
                    currentBlockType = type;
                };
                const color = document.createElement('div');
                color.className = 'slot-color';
                if(type === 'grass') color.style.background = '#4C9236';
                if(type === 'dirt') color.style.background = '#6d4c38';
                if(type === 'stone') color.style.background = '#7d7d7d';
                if(type === 'wood') color.style.background = '#634730';
                el.appendChild(color);
                hotbar.appendChild(el);
            });
            hotbar.children[1].click();
        }

        // --- INIT ---
        function init() {
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x87CEEB);
            scene.fog = new THREE.Fog(0x87CEEB, VIEW_SIZE * 1.5, VIEW_SIZE * 4);

            const aspect = window.innerWidth / window.innerHeight;
            // Größeren Viewport nutzen
            const d = VIEW_SIZE; 
            camera = new THREE.OrthographicCamera(-d * aspect, d * aspect, d, -d, 1, 1000);
            
            // Kamera Setup
            camera.position.set(200, 200, 200); 
            camera.lookAt(scene.position);

            renderer = new THREE.WebGLRenderer({ antialias: false });
            renderer.setSize(window.innerWidth / RENDER_SCALE, window.innerHeight / RENDER_SCALE);
            renderer.shadowMap.enabled = true;
            renderer.shadowMap.type = THREE.PCFSoftShadowMap;
            document.body.appendChild(renderer.domElement);

            // Licht
            const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
            scene.add(ambientLight);

            const dirLight = new THREE.DirectionalLight(0xffffff, 0.7);
            dirLight.position.set(100, 200, 50);
            dirLight.castShadow = true;
            dirLight.shadow.mapSize.width = 1024;
            dirLight.shadow.mapSize.height = 1024;
            const shadowSize = 300;
            dirLight.shadow.camera.left = -shadowSize;
            dirLight.shadow.camera.right = shadowSize;
            dirLight.shadow.camera.top = shadowSize;
            dirLight.shadow.camera.bottom = -shadowSize;
            scene.add(dirLight);

            raycaster = new THREE.Raycaster();
            mouse = new THREE.Vector2();

            // Auswahlbox (Wireframe)
            const boxGeo = new THREE.BoxGeometry(BLOCK_SIZE + 0.2, BLOCK_SIZE + 0.2, BLOCK_SIZE + 0.2);
            const edges = new THREE.EdgesGeometry(boxGeo);
            selectionBox = new THREE.LineSegments(edges, new THREE.LineBasicMaterial({ color: 0x000000, linewidth: 2 }));
            selectionBox.visible = false;
            scene.add(selectionBox);

            initMaterials();
            createWorld();
            createPlayer();

            window.addEventListener('resize', onWindowResize);
            document.addEventListener('keydown', onKeyDown);
            document.addEventListener('keyup', onKeyUp);
            
            // Interaction Event Listeners (Unified for Mouse/Touch)
            const canvas = renderer.domElement;
            canvas.addEventListener('pointerdown', onPointerDown);
            canvas.addEventListener('pointerup', onPointerUp);
            canvas.addEventListener('pointermove', onPointerMove);
            // Verhindert Rechtsklick Kontextmenü
            canvas.addEventListener('contextmenu', (e) => e.preventDefault());

            checkMobile();
            if(isMobile) initMobileControls();

            document.getElementById('start-btn').addEventListener('click', startGame);

            animate();
        }

        // --- WELT ---
        function createWorld() {
            const simplex = new SimplexNoise();
            const geometry = new THREE.BoxGeometry(BLOCK_SIZE, BLOCK_SIZE, BLOCK_SIZE);
            const offset = (CHUNK_SIZE * WORLD_SIZE * BLOCK_SIZE) / 2;

            for(let x = 0; x < CHUNK_SIZE * WORLD_SIZE; x++) {
                for(let z = 0; z < CHUNK_SIZE * WORLD_SIZE; z++) {
                    const nx = x / 25;
                    const nz = z / 25;
                    const h = Math.floor(Math.abs(simplex.noise2D(nx, nz)) * 5) + 1;

                    const posX = x * BLOCK_SIZE - offset;
                    const posZ = z * BLOCK_SIZE - offset;

                    for(let y = 0; y < h; y++) {
                        let mat = materials.dirt;
                        if(y === h - 1) mat = materials.grass;
                        if(y < h - 3) mat = materials.stone;

                        const mesh = new THREE.Mesh(geometry, mat);
                        mesh.position.set(posX, y * BLOCK_SIZE, posZ);
                        mesh.castShadow = true;
                        mesh.receiveShadow = true;
                        mesh.userData = { isBlock: true };
                        scene.add(mesh);
                        blocks.push(mesh);
                    }
                    if(h > 3 && Math.random() > 0.98) createTree(posX, h * BLOCK_SIZE, posZ);
                }
            }
            
            const planeGeo = new THREE.PlaneGeometry(2000, 2000);
            const planeMat = new THREE.MeshBasicMaterial({ color: 0x222222 });
            const plane = new THREE.Mesh(planeGeo, planeMat);
            plane.rotation.x = -Math.PI / 2;
            plane.position.y = -5;
            scene.add(plane);
        }

        function createTree(x, y, z) {
            const geoLog = new THREE.BoxGeometry(BLOCK_SIZE, BLOCK_SIZE, BLOCK_SIZE);
            const geoLeaves = new THREE.BoxGeometry(BLOCK_SIZE, BLOCK_SIZE, BLOCK_SIZE);
            for(let i=0; i<4; i++) {
                const mesh = new THREE.Mesh(geoLog, materials.wood);
                mesh.position.set(x, y + (i*BLOCK_SIZE), z);
                mesh.castShadow = true;
                mesh.receiveShadow = true;
                mesh.userData = { isBlock: true };
                scene.add(mesh);
                blocks.push(mesh);
            }
            const leafMat = materials.grass;
            for(let lx=-1; lx<=1; lx++) {
                for(let lz=-1; lz<=1; lz++) {
                    for(let ly=2; ly<=3; ly++) {
                        if(lx===0 && lz===0 && ly<3) continue;
                        const mesh = new THREE.Mesh(geoLeaves, leafMat);
                        mesh.position.set(x + lx*BLOCK_SIZE, y + (ly*BLOCK_SIZE), z + lz*BLOCK_SIZE);
                        mesh.userData = { isBlock: true };
                        scene.add(mesh);
                        blocks.push(mesh);
                    }
                }
            }
        }

        function createPlayer() {
            const geometry = new THREE.BoxGeometry(BLOCK_SIZE * 0.6, BLOCK_SIZE * 1.8, BLOCK_SIZE * 0.6);
            const material = new THREE.MeshBasicMaterial({ color: 0xff0000, wireframe: true, visible: false });
            player = new THREE.Mesh(geometry, material);
            player.position.set(0, 60, 0);
            scene.add(player);
        }

        // --- GAME LOOP ---
        function animate() {
            requestAnimationFrame(animate);

            if (!isGameActive) return;

            const time = performance.now();
            const delta = (time - prevTime) / 1000;

            // --- MOVEMENT ---
            velocity.x -= velocity.x * 10.0 * delta;
            velocity.z -= velocity.z * 10.0 * delta;
            velocity.y -= 9.8 * 30.0 * delta;

            direction.z = Number(input.forward) - Number(input.backward);
            direction.x = Number(input.right) - Number(input.left);
            direction.normalize();

            const speed = input.sprint ? 1500 : 800;

            if (input.forward || input.backward) velocity.z -= direction.z * speed * delta;
            if (input.left || input.right) velocity.x -= direction.x * speed * delta;

            const rayOrigin = player.position.clone();
            rayOrigin.y -= (BLOCK_SIZE * 0.9);
            const downRay = new THREE.Raycaster(player.position, new THREE.Vector3(0, -1, 0), 0, BLOCK_SIZE * 1.5);
            const intersections = downRay.intersectObjects(blocks);

            if (intersections.length > 0) {
                velocity.y = Math.max(0, velocity.y);
                canJump = true;
                const dist = intersections[0].distance;
                if(dist < BLOCK_SIZE * 0.9) {
                     player.position.y += (BLOCK_SIZE * 0.9) - dist;
                }
            } else {
                canJump = false;
            }

            if (input.jump && canJump) {
                velocity.y += 120;
                canJump = false;
            }

            const moveX = velocity.x * delta;
            const moveZ = velocity.z * delta;
            player.translateX(moveX);
            player.translateZ(moveZ);
            player.position.y += velocity.y * delta;

            if (player.position.y < -50) {
                player.position.set(0, 100, 0);
                velocity.set(0,0,0);
            }

            // --- KAMERA (STARR / RIGID FOLLOW) ---
            // Wir nutzen keine lerp() mehr für die Position, damit das Wackeln aufhört.
            // Die Kamera bleibt fest relativ zum Spieler.
            camera.position.set(
                player.position.x + 200,
                player.position.y + 200,
                player.position.z + 200
            );
            camera.lookAt(player.position);

            // --- RAYCAST & SELECTION BOX ---
            raycaster.setFromCamera(mouse, camera);
            const hits = raycaster.intersectObjects(blocks);
            
            if (hits.length > 0) {
                lastIntersect = hits[0];
                selectionBox.visible = true;
                selectionBox.position.copy(lastIntersect.object.position);
                
                // Pulsieren bei Long Press
                if (interactionTimer && (performance.now() - pointerDownTime > 300)) {
                    selectionBox.material.color.setHex(0xff0000); // Rot
                    if(!isLongPressAction) {
                         // Block brechen nach 500ms
                         if(performance.now() - pointerDownTime > 500) {
                             breakBlock(lastIntersect.object);
                             isLongPressAction = true; // Einmalige Aktion pro Drücken
                             selectionBox.visible = false;
                         }
                    }
                } else {
                    selectionBox.material.color.setHex(0x000000); // Schwarz
                }
            } else {
                selectionBox.visible = false;
                lastIntersect = null;
            }

            prevTime = time;
            renderer.render(scene, camera);
        }

        // --- INTERAKTION (POINTER EVENTS) ---
        function onPointerMove(event) {
            // Normale Mausbewegung tracken
            mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
            mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;
        }

        function onPointerDown(event) {
            if(!isGameActive) return;
            if(event.target.id === 'dpad-area' || event.target.id === 'dpad-stick' || event.target.id === 'btn-jump') return;

            // Koordinaten update falls Touch direkt startete
            mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
            mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;

            pointerDownTime = performance.now();
            isLongPressAction = false;
            
            // Timer starten (nur als Marker, Logik läuft in Animate)
            interactionTimer = true; 
        }

        function onPointerUp(event) {
            if(!interactionTimer) return;
            
            const duration = performance.now() - pointerDownTime;
            interactionTimer = false; // Stop timer

            // Wenn es kurz war und wir noch keinen Long-Press ausgeführt haben -> BAUEN
            if (duration < 300 && !isLongPressAction && lastIntersect) {
                placeBlock(lastIntersect);
            }
            
            // Auswahlbox reset
            if(selectionBox) selectionBox.material.color.setHex(0x000000);
        }

        function breakBlock(obj) {
            scene.remove(obj);
            const idx = blocks.indexOf(obj);
            if(idx > -1) blocks.splice(idx, 1);
        }

        function placeBlock(intersect) {
            const voxel = new THREE.Mesh(new THREE.BoxGeometry(BLOCK_SIZE, BLOCK_SIZE, BLOCK_SIZE), getMaterialForType(currentBlockType));
            voxel.userData = { isBlock: true };
            
            // Position
            voxel.position.copy(intersect.object.position).add(intersect.face.normal.multiplyScalar(BLOCK_SIZE));
            
            // Kollisionscheck Player
            const playerBox = new THREE.Box3().setFromObject(player);
            const voxelBox = new THREE.Box3().setFromObject(voxel);
            // Box3 Shrink etwas, damit man nicht beim Stehen am Rand blockiert wird
            voxelBox.expandByScalar(-1); 

            if(!playerBox.intersectsBox(voxelBox)) {
                voxel.castShadow = true;
                voxel.receiveShadow = true;
                scene.add(voxel);
                blocks.push(voxel);
            }
        }
        
        function getMaterialForType(type) {
            if(materials[type].length) return materials[type];
            return materials[type];
        }

        // --- STEUERUNG ---
        function onKeyDown(event) {
            switch (event.code) {
                case 'ArrowUp': case 'KeyW': input.forward = true; break;
                case 'ArrowLeft': case 'KeyA': input.left = true; break;
                case 'ArrowDown': case 'KeyS': input.backward = true; break;
                case 'ArrowRight': case 'KeyD': input.right = true; break;
                case 'Space': input.jump = true; break;
                case 'ShiftLeft': input.sprint = true; break;
            }
        }

        function onKeyUp(event) {
            switch (event.code) {
                case 'ArrowUp': case 'KeyW': input.forward = false; break;
                case 'ArrowLeft': case 'KeyA': input.left = false; break;
                case 'ArrowDown': case 'KeyS': input.backward = false; break;
                case 'ArrowRight': case 'KeyD': input.right = false; break;
                case 'Space': input.jump = false; break;
                case 'ShiftLeft': input.sprint = false; break;
            }
        }

        function startGame() {
            document.getElementById('main-menu').style.display = 'none';
            document.getElementById('ui-layer').style.display = 'block';
            isGameActive = true;
            prevTime = performance.now();
        }

        function onWindowResize() {
            const aspect = window.innerWidth / window.innerHeight;
            const d = VIEW_SIZE;
            
            camera.left = -d * aspect;
            camera.right = d * aspect;
            camera.top = d;
            camera.bottom = -d;
            
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth / RENDER_SCALE, window.innerHeight / RENDER_SCALE);
        }

        // --- MOBILE ---
        function checkMobile() {
            isMobile = /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent) || (navigator.platform === 'MacIntel' && navigator.maxTouchPoints > 1);
            if(isMobile) document.body.classList.add('mobile');
        }

        function initMobileControls() {
            const dpad = document.getElementById('dpad-area');
            const stick = document.getElementById('dpad-stick');
            const btnJump = document.getElementById('btn-jump');

            document.querySelector('.mobile-controls').style.display = 'block';

            let touchId = null;
            let startX, startY;
            const maxRadius = 50;

            dpad.addEventListener('touchstart', (e) => {
                e.preventDefault();
                e.stopPropagation();
                const touch = e.changedTouches[0];
                touchId = touch.identifier;
                startX = touch.clientX;
                startY = touch.clientY;
            }, {passive: false});

            dpad.addEventListener('touchmove', (e) => {
                e.preventDefault();
                e.stopPropagation();
                for(let i=0; i<e.changedTouches.length; i++) {
                    if(e.changedTouches[i].identifier === touchId) {
                        const touch = e.changedTouches[i];
                        let dx = touch.clientX - startX;
                        let dy = touch.clientY - startY;
                        
                        const distance = Math.min(Math.sqrt(dx*dx + dy*dy), maxRadius);
                        const angle = Math.atan2(dy, dx);
                        
                        dx = Math.cos(angle) * distance;
                        dy = Math.sin(angle) * distance;

                        stick.style.transform = `translate(calc(-50% + ${dx}px), calc(-50% + ${dy}px))`;

                        input.right = dx > 20;
                        input.left = dx < -20;
                        input.backward = dy > 20;
                        input.forward = dy < -20;
                    }
                }
            }, {passive: false});

            const resetJoystick = (e) => {
                if(e.type === 'touchend' && !Array.from(e.changedTouches).some(t => t.identifier === touchId)) return;
                touchId = null;
                stick.style.transform = `translate(-50%, -50%)`;
                input.forward = input.backward = input.left = input.right = false;
            };

            dpad.addEventListener('touchend', resetJoystick);
            dpad.addEventListener('touchcancel', resetJoystick);

            btnJump.addEventListener('touchstart', (e) => { e.preventDefault(); e.stopPropagation(); input.jump = true; });
            btnJump.addEventListener('touchend', (e) => { e.preventDefault(); e.stopPropagation(); input.jump = false; });
        }

        init();
    </script>
</body>
</html>
