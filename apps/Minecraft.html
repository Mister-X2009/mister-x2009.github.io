<!DOCTYPE html>
<html lang="de">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no, maximum-scale=1.0">
    <title>Voxel Survival Mobile Pro</title>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Inter:wght@400;700&family=VT323&display=swap');

        body {
            margin: 0;
            overflow: hidden;
            background-color: #000;
            font-family: 'Inter', sans-serif;
            user-select: none;
            touch-action: none;
        }

        canvas { display: block; }

        /* Start Overlay (für Fullscreen) */
        #start-screen {
            position: absolute;
            inset: 0;
            background: rgba(0,0,0,0.8);
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 9999;
            color: white;
        }
        #start-btn {
            padding: 20px 40px;
            font-size: 24px;
            background: #5f5;
            color: black;
            border: none;
            border-radius: 10px;
            font-weight: bold;
            margin-top: 20px;
        }

        /* HUD */
        #hud {
            position: absolute;
            inset: 0;
            pointer-events: none;
            display: flex;
            flex-direction: column;
            justify-content: flex-end;
            align-items: center;
            padding-bottom: 20px;
            z-index: 10;
        }

        #crosshair {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 12px;
            height: 12px;
            border: 2px solid rgba(255,255,255,0.8);
            border-radius: 50%;
            z-index: 10;
            box-shadow: 0 0 4px black;
        }

        #mining-progress {
            position: absolute;
            top: 55%;
            left: 50%;
            transform: translateX(-50%);
            width: 80px;
            height: 10px;
            background: rgba(0,0,0,0.5);
            border: 2px solid white;
            display: none;
            border-radius: 5px;
            overflow: hidden;
            z-index: 10;
        }
        #mining-bar { width: 0%; height: 100%; background: #0f0; }

        #status-bars {
            display: flex;
            gap: 15px;
            margin-bottom: 15px;
            pointer-events: auto;
        }
        .bar-container {
            width: 100px;
            height: 10px;
            background: rgba(0,0,0,0.5);
            border: 2px solid #fff;
            border-radius: 5px;
            overflow: hidden;
        }
        .bar-fill { height: 100%; transition: width 0.3s; }
        #health-fill { background: #ff4444; width: 100%; }
        #hunger-fill { background: #ffa500; width: 100%; }

        /* Hotbar */
        #hotbar {
            display: flex;
            gap: 5px;
            background: rgba(0,0,0,0.6);
            padding: 5px;
            border-radius: 8px;
            pointer-events: auto;
        }
        .slot {
            width: 50px;
            height: 50px;
            border: 3px solid #555;
            background: #333;
            display: flex;
            justify-content: center;
            align-items: center;
            position: relative;
            color: white;
            font-family: 'VT323', monospace;
            border-radius: 6px;
            touch-action: none; /* Wichtig für Drag & Drop */
        }
        .slot.active { border-color: #fff; background: #666; }
        .slot .icon { width: 32px; height: 32px; border: 1px solid rgba(0,0,0,0.5); }
        .count { position: absolute; bottom: 2px; right: 4px; pointer-events: none; font-size: 16px; text-shadow: 1px 1px 0 #000; }

        /* Controls */
        #joy-base {
            position: absolute;
            bottom: 50px;
            left: 50px;
            width: 120px;
            height: 120px;
            background: rgba(255,255,255,0.1);
            border: 2px solid rgba(255,255,255,0.2);
            border-radius: 50%;
            pointer-events: auto;
            z-index: 20;
        }
        #joy-knob {
            position: absolute;
            top: 35px;
            left: 35px;
            width: 50px;
            height: 50px;
            background: rgba(255,255,255,0.5);
            border-radius: 50%;
        }

        #action-area {
            position: absolute;
            bottom: 50px;
            right: 50px;
            display: flex;
            flex-direction: column;
            gap: 20px;
            pointer-events: auto;
            z-index: 20;
        }
        .action-btn {
            width: 70px;
            height: 70px;
            background: rgba(255,255,255,0.2);
            border: 3px solid white;
            border-radius: 50%;
            display: flex;
            justify-content: center;
            align-items: center;
            color: white;
            font-weight: bold;
            font-size: 14px;
            backdrop-filter: blur(5px);
        }

        /* Inventory Overlay */
        #inv-overlay {
            position: absolute;
            inset: 0;
            background: rgba(0,0,0,0.85);
            display: none;
            justify-content: center;
            align-items: center;
            z-index: 100;
            pointer-events: auto;
        }
        #inv-panel {
            background: #aaa;
            border: 4px solid #fff;
            padding: 15px;
            width: 90%;
            max-width: 500px;
            border-radius: 8px;
            box-shadow: 0 0 20px black;
        }
        .grid { display: grid; gap: 5px; margin-top: 10px; }
        .inv-grid { grid-template-columns: repeat(auto-fill, minmax(50px, 1fr)); }
        
        /* Drag Helper */
        #drag-helper {
            position: fixed;
            pointer-events: none;
            z-index: 1000;
            width: 50px;
            height: 50px;
            display: none;
            opacity: 0.8;
        }
    </style>
</head>
<body>

    <div id="start-screen">
        <h1>VOXEL SURVIVAL</h1>
        <p>Tippe auf Start für Vollbild</p>
        <button id="start-btn">STARTEN</button>
    </div>

    <div id="hud">
        <div id="crosshair"></div>
        <div id="mining-progress"><div id="mining-bar"></div></div>
        <div id="status-bars">
            <div class="bar-container"><div id="health-fill" class="bar-fill"></div></div>
            <div class="bar-container"><div id="hunger-fill" class="bar-fill"></div></div>
        </div>
        <div id="hotbar"></div>
    </div>

    <div id="joy-base"><div id="joy-knob"></div></div>

    <div id="action-area">
        <div class="action-btn" id="btn-jump">SPRUNG</div>
        <div class="action-btn" id="btn-inv">INV</div>
    </div>

    <div id="inv-overlay">
        <div id="inv-panel">
            <div style="display:flex; justify-content: space-between; align-items: center;">
                <h2 style="margin:0; color:#333; font-family:'VT323'; font-size: 28px;">INVENTAR</h2>
                <button onclick="toggleInv()" style="padding:5px 15px; background:#d55; border:none; color:white; border-radius:4px;">X</button>
            </div>
            <div id="inv-grid" class="grid inv-grid"></div>
            <p style="color:#333; font-size:12px; margin-top:10px;">Ziehe Items zum Bewegen (Drag & Drop)</p>
        </div>
    </div>

    <!-- Visuelles Element beim Ziehen -->
    <div id="drag-helper"></div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/simplex-noise/2.4.0/simplex-noise.min.js"></script>

    <script>
        const BLOCK_TYPES = {
            air: { id: 0 },
            grass: { id: 1, color: '#5d8c36', hardness: 0.6 },
            dirt: { id: 2, color: '#553a26', hardness: 0.5 },
            stone: { id: 3, color: '#777777', hardness: 1.5 },
            log: { id: 4, color: '#4b3621', hardness: 1.0 },
            leaves: { id: 5, color: '#2d5a27', hardness: 0.2 },
            sand: { id: 6, color: '#d2b48c', hardness: 0.5 }
        };

        let scene, camera, renderer, raycaster, clock;
        let player, velocity = new THREE.Vector3();
        let blocks = [], inventory = new Array(30).fill(null); // 5 Hotbar + 25 Main
        let hotbarIndex = 0, yaw = 0, pitch = 0;
        let isMining = false, miningStart = 0, miningTarget = null;
        let canJump = false;
        let health = 20, hunger = 20;

        // Texturen Cache
        const textureCache = {};

        // Inputs
        const moveInput = { x: 0, y: 0 };
        let lookTouchId = null, lastLookPos = { x: 0, y: 0 };
        let isMovingCamera = false;
        let tapStartTime = 0;

        // Drag & Drop Vars
        let dragSrcIndex = -1;
        let dragEl = document.getElementById('drag-helper');

        function init() {
            // Start Button Handler
            document.getElementById('start-btn').addEventListener('click', () => {
                const el = document.documentElement;
                if(el.requestFullscreen) el.requestFullscreen();
                else if(el.webkitRequestFullscreen) el.webkitRequestFullscreen();
                document.getElementById('start-screen').style.display = 'none';
            });

            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x87CEEB);
            scene.fog = new THREE.Fog(0x87CEEB, 20, 60);

            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            
            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
            renderer.shadowMap.enabled = true;
            renderer.shadowMap.type = THREE.PCFSoftShadowMap;
            document.body.appendChild(renderer.domElement);

            // Lighting setup for better shadows
            scene.add(new THREE.AmbientLight(0xffffff, 0.4)); // Weniger Ambient für Kontrast
            const sun = new THREE.DirectionalLight(0xffffff, 0.9);
            sun.position.set(20, 50, 20);
            sun.castShadow = true;
            sun.shadow.mapSize.width = 1024;
            sun.shadow.mapSize.height = 1024;
            sun.shadow.camera.near = 0.5;
            sun.shadow.camera.far = 100;
            sun.shadow.camera.left = -30;
            sun.shadow.camera.right = 30;
            sun.shadow.camera.top = 30;
            sun.shadow.camera.bottom = -30;
            scene.add(sun);

            raycaster = new THREE.Raycaster();
            clock = new THREE.Clock();

            player = new THREE.Group();
            player.position.set(0, 10, 0);
            scene.add(player);
            player.add(camera);

            generateTextures(); // Texturen vor Welt generieren
            generateWorld();
            setupInventory();
            setupControls();
            
            animate();
        }

        // --- VISUALS ---
        function generateTextures() {
            const createTex = (colorHex) => {
                const size = 64;
                const canvas = document.createElement('canvas');
                canvas.width = size; canvas.height = size;
                const ctx = canvas.getContext('2d');
                
                // Base Color
                ctx.fillStyle = colorHex;
                ctx.fillRect(0, 0, size, size);

                // Noise
                for(let i=0; i<400; i++) {
                    ctx.fillStyle = Math.random() > 0.5 ? 'rgba(255,255,255,0.1)' : 'rgba(0,0,0,0.1)';
                    const x = Math.random() * size;
                    const y = Math.random() * size;
                    ctx.fillRect(x, y, 2, 2);
                }

                // Border (damit man Blöcke unterscheidet)
                ctx.strokeStyle = 'rgba(0,0,0,0.2)';
                ctx.lineWidth = 4;
                ctx.strokeRect(0, 0, size, size);

                const tex = new THREE.CanvasTexture(canvas);
                tex.magFilter = THREE.NearestFilter;
                tex.minFilter = THREE.NearestFilter;
                return tex;
            };

            Object.values(BLOCK_TYPES).forEach(type => {
                if(type.id > 0) textureCache[type.id] = createTex(type.color);
            });
        }

        function getMaterial(id) {
            return new THREE.MeshLambertMaterial({ map: textureCache[id] });
        }

        function generateWorld() {
            const simplex = new SimplexNoise();
            for(let x = -8; x < 8; x++) {
                for(let z = -8; z < 8; z++) {
                    const h = Math.floor(simplex.noise2D(x/12, z/12) * 3) + 5;
                    for(let y = 0; y < h; y++) {
                        let id = 2; // Dirt
                        if (y === h-1) id = 1; // Grass
                        if (y < h-3) id = 3; // Stone
                        if (y === 0) id = 3; // Bedrockish
                        addBlock(x, y, z, id);
                    }
                    // Tree chance
                    if(Math.random() > 0.98 && h > 4) createTree(x, h, z);
                }
            }
        }

        function createTree(x, y, z) {
            for(let i=0; i<4; i++) addBlock(x, y+i, z, 4);
            for(let lx=-1; lx<=1; lx++) {
                for(let ly=0; ly<=1; ly++) {
                    for(let lz=-1; lz<=1; lz++) {
                        if(lx===0 && lz===0 && ly===0) continue;
                        addBlock(x+lx, y+3+ly, z+lz, 5);
                    }
                }
            }
        }

        function addBlock(x, y, z, id) {
            const mesh = new THREE.Mesh(new THREE.BoxGeometry(1, 1, 1), getMaterial(id));
            mesh.position.set(x, y, z);
            mesh.userData.typeId = id;
            mesh.castShadow = true;
            mesh.receiveShadow = true;
            scene.add(mesh);
            blocks.push(mesh);
        }

        // --- CONTROLS & PHYSICS ---
        function setupControls() {
            const joyBase = document.getElementById('joy-base');
            const joyKnob = document.getElementById('joy-knob');

            joyBase.addEventListener('touchmove', (e) => {
                e.preventDefault();
                const touch = e.touches[0];
                const rect = joyBase.getBoundingClientRect();
                const centerX = rect.left + rect.width / 2;
                const centerY = rect.top + rect.height / 2;
                const dx = touch.clientX - centerX;
                const dy = touch.clientY - centerY;
                const dist = Math.min(Math.sqrt(dx*dx+dy*dy), 40);
                const angle = Math.atan2(dy, dx);
                joyKnob.style.transform = `translate(${Math.cos(angle)*dist}px, ${Math.sin(angle)*dist}px)`;
                moveInput.x = (Math.cos(angle) * dist) / 40;
                moveInput.y = -(Math.sin(angle) * dist) / 40;
            });

            joyBase.addEventListener('touchend', () => {
                joyKnob.style.transform = 'translate(0,0)';
                moveInput.x = 0; moveInput.y = 0;
            });

            window.addEventListener('touchstart', (e) => {
                // Ignore HUD touches for look
                if(e.target.closest('#joy-base') || e.target.closest('#action-area') || e.target.closest('#inv-overlay') || e.target.closest('#hud')) return;

                const touch = e.touches[0];
                if (touch.clientX > window.innerWidth / 3) {
                    lookTouchId = touch.identifier;
                    lastLookPos = { x: touch.clientX, y: touch.clientY };
                    isMovingCamera = false;
                    tapStartTime = Date.now();
                    
                    clearTimeout(window.miningTimer);
                    window.miningTimer = setTimeout(() => {
                        if (!isMovingCamera) startMining();
                    }, 350);
                }
            }, { passive: false });

            window.addEventListener('touchmove', (e) => {
                for (let i = 0; i < e.changedTouches.length; i++) {
                    const t = e.changedTouches[i];
                    if (t.identifier === lookTouchId) {
                        const dx = t.clientX - lastLookPos.x;
                        const dy = t.clientY - lastLookPos.y;
                        
                        if (Math.abs(dx) > 2 || Math.abs(dy) > 2) {
                            isMovingCamera = true;
                            clearTimeout(window.miningTimer);
                            stopMining();
                        }

                        yaw -= dx * 0.005;
                        pitch -= dy * 0.005;
                        pitch = Math.max(-Math.PI/2, Math.min(Math.PI/2, pitch));
                        
                        player.rotation.y = yaw;
                        camera.rotation.x = pitch;
                        lastLookPos = { x: t.clientX, y: t.clientY };
                    }
                }
            });

            window.addEventListener('touchend', (e) => {
                for (let i = 0; i < e.changedTouches.length; i++) {
                    if (e.changedTouches[i].identifier === lookTouchId) {
                        clearTimeout(window.miningTimer);
                        if (!isMovingCamera && Date.now() - tapStartTime < 300) placeBlock();
                        stopMining();
                        lookTouchId = null;
                    }
                }
            });

            document.getElementById('btn-jump').addEventListener('touchstart', () => { if (canJump) velocity.y = 0.13; });
            document.getElementById('btn-inv').addEventListener('touchstart', toggleInv);
        }

        function startMining() {
            raycaster.setFromCamera({x:0, y:0}, camera);
            const hits = raycaster.intersectObjects(blocks);
            if (hits.length > 0 && hits[0].distance < 4.5) {
                isMining = true;
                miningStart = Date.now();
                miningTarget = hits[0].object;
                document.getElementById('mining-progress').style.display = 'block';
            }
        }

        function stopMining() {
            isMining = false; miningTarget = null;
            document.getElementById('mining-progress').style.display = 'none';
        }

        function placeBlock() {
            raycaster.setFromCamera({x:0, y:0}, camera);
            const hits = raycaster.intersectObjects(blocks);
            if (hits.length > 0 && hits[0].distance < 4.5) {
                const item = inventory[hotbarIndex];
                if (!item) return;
                const pos = hits[0].object.position.clone().add(hits[0].face.normal);
                // Simple collision check
                if(pos.distanceTo(player.position) > 1.2) {
                    addBlock(pos.x, pos.y, pos.z, item.id);
                }
            }
        }

        function animate() {
            requestAnimationFrame(animate);
            const delta = clock.getDelta();

            velocity.y -= 0.009; // Gravity
            player.translateZ(-moveInput.y * 0.1);
            player.translateX(moveInput.x * 0.1);
            player.position.y += velocity.y;

            // Ground check
            raycaster.set(player.position, new THREE.Vector3(0,-1,0));
            const ground = raycaster.intersectObjects(blocks);
            if (ground.length > 0 && ground[0].distance < 1.6) {
                player.position.y += 1.6 - ground[0].distance;
                velocity.y = 0; canJump = true;
            } else { canJump = false; }

            // Mining progress
            if (isMining && miningTarget) {
                const type = Object.values(BLOCK_TYPES).find(b => b.id === miningTarget.userData.typeId);
                const progress = (Date.now() - miningStart) / (type.hardness * 1000);
                document.getElementById('mining-bar').style.width = Math.min(progress*100, 100) + '%';
                if (progress >= 1) {
                    // Drop item (simplified: add to inv if space)
                    addItemToInv(miningTarget.userData.typeId, 1);
                    scene.remove(miningTarget);
                    blocks = blocks.filter(b => b !== miningTarget);
                    stopMining();
                }
            }
            renderer.render(scene, camera);
        }

        // --- INVENTORY LOGIC ---
        function setupInventory() {
            // Start Items
            inventory[0] = { id: 1, count: 64 };
            inventory[1] = { id: 2, count: 64 };
            inventory[2] = { id: 3, count: 64 };
            inventory[3] = { id: 4, count: 64 };
            inventory[4] = { id: 5, count: 64 };
            updateUI();
        }

        function addItemToInv(id, count) {
             // Stack logic omitted for brevity, just find empty
            let type = Object.values(BLOCK_TYPES).find(t=>t.id===id);
            // Try stack
            let existing = inventory.find(i => i && i.id === id);
            if(existing) { existing.count += count; }
            else {
                let empty = inventory.findIndex(i => i === null);
                if(empty !== -1) inventory[empty] = { id, count };
            }
            updateUI();
        }

        function updateUI() {
            const hb = document.getElementById('hotbar');
            hb.innerHTML = '';
            // Hotbar (Slots 0-4)
            for(let i=0; i<5; i++) {
                const item = inventory[i];
                hb.innerHTML += `<div class="slot ${i===hotbarIndex?'active':''}" onmousedown="setHotbar(${i})" ontouchstart="setHotbar(${i})">${item ? renderItem(item) : ''}</div>`;
            }

            // Inventory Grid (All Slots)
            const invGrid = document.getElementById('inv-grid');
            if(document.getElementById('inv-overlay').style.display === 'flex') {
                invGrid.innerHTML = '';
                inventory.forEach((item, i) => {
                    const slot = document.createElement('div');
                    slot.className = 'slot';
                    if(i < 5) slot.style.borderColor = '#5f5'; // Highlight Hotbar slots in grid
                    slot.innerHTML = item ? renderItem(item) : '';
                    
                    // Drag Events
                    slot.addEventListener('touchstart', (e) => handleDragStart(e, i));
                    slot.addEventListener('mousedown', (e) => handleDragStart(e, i));
                    
                    invGrid.appendChild(slot);
                });
            }
        }

        function renderItem(item) {
            const type = Object.values(BLOCK_TYPES).find(t => t.id === item.id);
            return `<div class="icon" style="background:${type.color}"></div><span class="count">${item.count}</span>`;
        }

        function setHotbar(i) { hotbarIndex = i; updateUI(); }

        function toggleInv() {
            const el = document.getElementById('inv-overlay');
            el.style.display = el.style.display === 'flex' ? 'none' : 'flex';
            updateUI();
        }

        // --- DRAG AND DROP ---
        function handleDragStart(e, index) {
            if(!inventory[index]) return;
            e.preventDefault(); // Prevent scroll
            dragSrcIndex = index;
            
            const item = inventory[index];
            dragEl.innerHTML = renderItem(item);
            dragEl.style.display = 'block';
            
            const touch = e.touches ? e.touches[0] : e;
            updateDragPos(touch.clientX, touch.clientY);

            const moveHandler = (moveE) => {
                const t = moveE.touches ? moveE.touches[0] : moveE;
                updateDragPos(t.clientX, t.clientY);
            };

            const endHandler = (endE) => {
                const t = endE.changedTouches ? endE.changedTouches[0] : endE;
                dragEl.style.display = 'none';
                
                // Find drop target
                const target = document.elementFromPoint(t.clientX, t.clientY);
                const slotDiv = target.closest('.slot');
                if(slotDiv && invGridContains(slotDiv)) {
                    // Simple hack: find index by counting children
                    const children = Array.from(document.getElementById('inv-grid').children);
                    const targetIndex = children.indexOf(slotDiv);
                    if(targetIndex !== -1 && targetIndex !== dragSrcIndex) {
                        // Swap
                        const temp = inventory[targetIndex];
                        inventory[targetIndex] = inventory[dragSrcIndex];
                        inventory[dragSrcIndex] = temp;
                        updateUI();
                    }
                }

                document.removeEventListener('touchmove', moveHandler);
                document.removeEventListener('touchend', endHandler);
                document.removeEventListener('mousemove', moveHandler);
                document.removeEventListener('mouseup', endHandler);
            };

            document.addEventListener('touchmove', moveHandler, {passive: false});
            document.addEventListener('touchend', endHandler);
            document.addEventListener('mousemove', moveHandler);
            document.addEventListener('mouseup', endHandler);
        }

        function updateDragPos(x, y) {
            dragEl.style.left = (x - 25) + 'px';
            dragEl.style.top = (y - 25) + 'px';
        }

        function invGridContains(el) {
            return document.getElementById('inv-grid').contains(el);
        }

        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });

        init();
    </script>
</body>
</html>
